{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to gns3fy Docs! gns3fy is a Python wrapper around GNS3 Server API . Its main objective is to interact with the GNS3 server in a programatic way, so it can be integrated with the likes of Ansible, docker and scripts. Install pip install gns3fy Development version Use poetry to install the package when cloning it. Quick Start >>> import gns3fy # Define the server object to establish the connection >>> gns3_server = gns3fy.Gns3Connector(\"http://<server address>:3080\") # Define the lab you want to load and assign the server connector >>> lab = gns3fy.Project(name=\"API_TEST\", connector=gns3_server) # Retrieve its information and display >>> lab.get() >>> print(lab) \"Project(project_id='4b21dfb3-675a-4efa-8613-2f7fb32e76fe', name='API_TEST', status='opened', ...)\" # Access the project attributes >>> print(f\"Name: {lab.name} -- Status: {lab.status} -- Is auto_closed?: {lab.auto_close}\") \"Name: API_TEST -- Status: closed -- Is auto_closed?: False\" # Open the project >>> lab.open() >>> lab.status opened # Verify the stats >>> lab.stats {'drawings': 0, 'links': 4, 'nodes': 6, 'snapshots': 0} # List the names and status of all the nodes in the project >>> for node in lab.nodes: ... print(f\"Node: {node.name} -- Node Type: {node.node_type} -- Status: {node.status}\") \"Node: Ethernetswitch-1 -- Node Type: ethernet_switch -- Status: started\" ... Release Notes Please see the Release Notes for details","title":"Overview"},{"location":"#install","text":"pip install gns3fy","title":"Install"},{"location":"#development-version","text":"Use poetry to install the package when cloning it.","title":"Development version"},{"location":"#quick-start","text":">>> import gns3fy # Define the server object to establish the connection >>> gns3_server = gns3fy.Gns3Connector(\"http://<server address>:3080\") # Define the lab you want to load and assign the server connector >>> lab = gns3fy.Project(name=\"API_TEST\", connector=gns3_server) # Retrieve its information and display >>> lab.get() >>> print(lab) \"Project(project_id='4b21dfb3-675a-4efa-8613-2f7fb32e76fe', name='API_TEST', status='opened', ...)\" # Access the project attributes >>> print(f\"Name: {lab.name} -- Status: {lab.status} -- Is auto_closed?: {lab.auto_close}\") \"Name: API_TEST -- Status: closed -- Is auto_closed?: False\" # Open the project >>> lab.open() >>> lab.status opened # Verify the stats >>> lab.stats {'drawings': 0, 'links': 4, 'nodes': 6, 'snapshots': 0} # List the names and status of all the nodes in the project >>> for node in lab.nodes: ... print(f\"Node: {node.name} -- Node Type: {node.node_type} -- Status: {node.status}\") \"Node: Ethernetswitch-1 -- Node Type: ethernet_switch -- Status: started\" ...","title":"Quick Start"},{"location":"#release-notes","text":"Please see the Release Notes for details","title":"Release Notes"},{"location":"api_reference/","text":"gns3fy Gns3Connector Objects def __init__(self, url=None, user=None, cred=None, verify=False, api_version=2) Connector to be use for interaction against GNS3 server controller API. Attributes: url (str): URL of the GNS3 server ( required ) user (str): User used for authentication cred (str): Password used for authentication verify (bool): Whether or not to verify SSL api_version (int): GNS3 server REST API version api_calls : Counter of amount of http_calls has been performed base_url : url passed + api_version session : Requests Session object Returns: Gns3Connector instance Example: >>> server = Gns3Connector(url=\"http://<address>:3080\") >>> print(server.get_version()) {'local': False, 'version': '2.2.0b4'} Gns3Connector.__init__() def __init__(self, url=None, user=None, cred=None, verify=False, api_version=2) Gns3Connector.http_call() def http_call(self, method, url, data=None, json_data=None, headers=None, verify=False, params=None) Performs the HTTP operation actioned Required Attributes: method (enum): HTTP method to perform: get, post, put, delete, head, patch ( required ) url (str): URL target ( required ) data : Dictionary or byte of request body data to attach to the Request json_data : Dictionary or List of dicts to be passed as JSON object/array headers : ictionary of HTTP Headers to attach to the Request verify : SSL Verification params : Dictionary or bytes to be sent in the query string for the Request Gns3Connector.get_version() def get_version(self) Returns the version information of GNS3 server Gns3Connector.projects_summary() def projects_summary(self, is_print=True) Returns a summary of the projects in the server. If is_print is False , it will return a list of tuples like: [(name, project_id, total_nodes, total_links, status) ...] Gns3Connector.get_projects() def get_projects(self) Returns the list of the projects on the server Gns3Connector.get_project() def get_project(self, name=None, project_id=None) Retrieves a project from either a name or ID Required Attributes: name or project_id Gns3Connector.templates_summary() def templates_summary(self, is_print=True) Returns a summary of the templates in the server. If is_print is False , it will return a list of tuples like: [(name, template_id, template_type, builtin, console_type, category) ...] Gns3Connector.get_templates() def get_templates(self) Returns the templates defined on the server. Gns3Connector.get_template() def get_template(self, name=None, template_id=None) Retrieves a template from either a name or ID Required Attributes: name or template_id Gns3Connector.get_nodes() def get_nodes(self, project_id) Retieves the nodes defined on the project Required Attributes: project_id Gns3Connector.get_node() def get_node(self, project_id, node_id) Returns the node by locating its ID. Required Attributes: project_id node_id Gns3Connector.get_links() def get_links(self, project_id) Retrieves the links defined in the project. Required Attributes: project_id Gns3Connector.get_link() def get_link(self, project_id, link_id) Returns the link by locating its ID. Required Attributes: project_id link_id Gns3Connector.create_project() def create_project(self, kwargs) Pass a dictionary type object with the project parameters to be created. Required Attributes: name Returns JSON project information Gns3Connector.delete_project() def delete_project(self, project_id) Deletes a project from server. Required Attributes: project_id Link Objects GNS3 Link API object. For more information visit: Links Endpoint API information Attributes: link_id (str): Link UUID ( required to be set when using get method) link_type (enum): Possible values: ethernet, serial project_id (str): Project UUID ( required ) connector (object): Gns3Connector instance used for interaction ( required ) suspend (bool): Suspend the link nodes (list): List of the Nodes and ports ( required when using create method, see Features/Link creation on the docs) filters (dict): Packet filter. This allow to simulate latency and errors capturing (bool): Read only property. True if a capture running on the link capture_file_path (str): Read only property. The full path of the capture file if capture is running capture_file_name (str): Read only property. The name of the capture file if capture is running Returns: Link instance Example: >>> link = Link(project_id=<pr_id>, link_id=<link_id> connector=<Gns3Connector instance>) >>> link.get() >>> print(link.link_type) 'ethernet' Link.get() def get(self) Retrieves the information from the link endpoint. Required Attributes: project_id connector link_id Link.delete() def delete(self) Deletes a link endpoint from the project. It sets to None the attributes link_id when executed sucessfully Required Attributes: project_id connector link_id Link.create() def create(self) Creates a link endpoint Required Attributes: project_id connector nodes Node Objects GNS3 Node API object. For more information visit: Node Endpoint API information Attributes: name (str): Node name ( required when using create method) project_id (str): Project UUID ( required ) node_id (str): Node UUID ( required when using get method) compute_id (str): Compute identifier ( required , default=local) node_type (enum): frame_relay_switch, atm_switch, docker, dynamips, vpcs, traceng, virtualbox, vmware, iou, qemu ( required when using create method) connector (object): Gns3Connector instance used for interaction ( required ) template_id : Template UUID from the which the node is from. template : Template name from the which the node is from. node_directory (str): Working directory of the node. Read only status (enum): Possible values: stopped, started, suspended ports (list): List of node ports, READ only port_name_format (str): Formating for port name {0} will be replace by port number port_segment_size (int): Size of the port segment first_port_name (str): Name of the first port properties (dict): Properties specific to an emulator locked (bool): Whether the element locked or not label (dict): TBC console (int): Console TCP port console_host (str): Console host console_auto_start (bool): Automatically start the console when the node has started command_line (str): Command line use to start the node custom_adapters (list): TBC height (int): Height of the node, READ only width (int): Width of the node, READ only symbol (str): Symbol of the node x (int): X position of the node y (int): Y position of the node `z (int): Z position of the node Returns: Node instance Example: >>> alpine = Node(name=\"alpine1\", node_type=\"docker\", template=\"alpine\", project_id=<pr_id>, connector=<Gns3Connector instance>) >>> alpine.create() >>> print(alpine.node_id) 'SOME-UUID-GENERATED' Node.get() def get(self, get_links=True) Retrieves the node information. When get_links is True it also retrieves the links respective to the node. Required Attributes: project_id connector node_id Node.get_links() def get_links(self) Retrieves the links of the respective node. They will be saved at the links attribute Required Attributes: project_id connector node_id Node.start() def start(self) Starts the node. Required Attributes: project_id connector node_id Node.stop() def stop(self) Stops the node. Required Attributes: project_id connector node_id Node.reload() def reload(self) Reloads the node. Required Attributes: project_id connector node_id Node.suspend() def suspend(self) Suspends the node. Required Attributes: project_id connector node_id Node.create() def create(self, extra_properties={}) Creates a node. By default it will fetch the nodes properties for creation based on the template or template_id attribute supplied. This can be overriden/updated by sending a dictionary of the properties under extra_properties . Required Attributes: project_id connector compute_id : Defaults to \"local\" name node_type template or template_id Node.delete() def delete(self) Deletes the node from the project. It sets to None the attributes node_id and name when executed successfully Required Attributes: project_id connector node_id Project Objects GNS3 Project API object. For more information visit: Project Endpoint API information Attributes: name : Project name ( required when using create method) project_id (str): Project UUID ( required ) connector (object): Gns3Connector instance used for interaction ( required ) status (enum): Possible values: opened, closed path (str): Path of the project on the server filename (str): Project filename auto_start (bool): Project start when opened auto_close (bool): Project auto close when client cut off the notifications feed auto_open (bool): Project open when GNS3 start drawing_grid_size (int): Grid size for the drawing area for drawings grid_size (int): Grid size for the drawing area for nodes scene_height (int): Height of the drawing area scene_width (int): Width of the drawing area show_grid (bool): Show the grid on the drawing area show_interface_labels (bool): Show interface labels on the drawing area show_layers (bool): Show layers on the drawing area snap_to_grid (bool): Snap to grid on the drawing area supplier (dict): Supplier of the project variables (list): Variables required to run the project zoom (int): Zoom of the drawing area stats (dict): Project stats nodes (list): List of Node instances present on the project links (list): List of Link instances present on the project Returns: Project instance Example: >>> lab = Project(name=\"lab\", connector=<Gns3Connector instance>) >>> lab.create() >>> print(lab.status) 'opened' Project.get() def get(self, get_links=True, get_nodes=True, get_stats=True) Retrieves the projects information. get_links : When true it also queries for the links inside the project get_nodes : When true it also queries for the nodes inside the project get_stats : When true it also queries for the stats inside the project Required Attributes: connector project_id or name Project.create() def create(self) Creates the project. Required Attributes: name connector Project.update() def update(self, kwargs) Updates the project instance by passing the keyword arguments of the attributes you want to be updated Example: lab.update(auto_close=True) This will update the project auto_close attribute to True Required Attributes: project_id connector Project.delete() def delete(self) Deletes the project from the server. It sets to None the attributes project_id and name when executed successfully Required Attributes: project_id connector Project.close() def close(self) Closes the project on the server. Required Attributes: project_id connector Project.open() def open(self) Opens the project on the server. Required Attributes: project_id connector Project.get_stats() def get_stats(self) Retrieve the stats of the project. Required Attributes: project_id connector Project.get_nodes() def get_nodes(self) Retrieve the nodes of the project. Required Attributes: project_id connector Project.get_links() def get_links(self) Retrieve the links of the project. Required Attributes: project_id connector Project.start_nodes() def start_nodes(self, poll_wait_time=5) Starts all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector Project.stop_nodes() def stop_nodes(self, poll_wait_time=5) Stops all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector Project.reload_nodes() def reload_nodes(self, poll_wait_time=5) Reloads all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector Project.suspend_nodes() def suspend_nodes(self, poll_wait_time=5) Suspends all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector Project.nodes_summary() def nodes_summary(self, is_print=True) Returns a summary of the nodes insode the project. If is_print is False , it will return a list of tuples like: [(node_name, node_status, node_console, node_id) ...] Required Attributes: project_id connector Project.nodes_inventory() def nodes_inventory(self) Returns an inventory-style dictionary of the nodes Example: { \"router01\": { \"hostname\": \"127.0.0.1\", \"name\": \"router01\", \"console_port\": 5077, \"type\": \"vEOS\" } } Required Attributes: project_id connector Project.links_summary() def links_summary(self, is_print=True) Returns a summary of the links insode the project. If is_print is False, it will return a list of tuples like: [(node_a, port_a, node_b, port_b) ...] Required Attributes: project_id connector Project.get_node() def get_node(self, name=None, node_id=None) Returns the Node object by searching for the name or the node_id . Required Attributes: project_id connector name or node_id NOTE: Run method get_nodes() manually to refresh list of nodes if necessary Project.get_link() def get_link(self, link_id) Returns the Link object by locating its ID Required Attributes: project_id connector link_id NOTE: Run method get_links() manually to refresh list of links if necessary Project.create_node() def create_node(self, name=None, kwargs) Creates a node. Required Attributes: project_id connector Required Keyword attributes: name node_type compute_id : Defaults to \"local\" template or template_id Project.create_link() def create_link(self, node_a, port_a, node_b, port_b) Creates a link. Required Attributes: project_id connector node_a : Node name of the A side port_a : Port name of the A side (must match the name attribute of the port) node_b : Node name of the B side port_b : Port name of the B side (must match the name attribute of the port)","title":"API Reference"},{"location":"api_reference/#gns3connector-objects","text":"def __init__(self, url=None, user=None, cred=None, verify=False, api_version=2) Connector to be use for interaction against GNS3 server controller API. Attributes: url (str): URL of the GNS3 server ( required ) user (str): User used for authentication cred (str): Password used for authentication verify (bool): Whether or not to verify SSL api_version (int): GNS3 server REST API version api_calls : Counter of amount of http_calls has been performed base_url : url passed + api_version session : Requests Session object Returns: Gns3Connector instance Example: >>> server = Gns3Connector(url=\"http://<address>:3080\") >>> print(server.get_version()) {'local': False, 'version': '2.2.0b4'}","title":"Gns3Connector Objects"},{"location":"api_reference/#gns3connector__init__","text":"def __init__(self, url=None, user=None, cred=None, verify=False, api_version=2)","title":"Gns3Connector.__init__()"},{"location":"api_reference/#gns3connectorhttp_call","text":"def http_call(self, method, url, data=None, json_data=None, headers=None, verify=False, params=None) Performs the HTTP operation actioned Required Attributes: method (enum): HTTP method to perform: get, post, put, delete, head, patch ( required ) url (str): URL target ( required ) data : Dictionary or byte of request body data to attach to the Request json_data : Dictionary or List of dicts to be passed as JSON object/array headers : ictionary of HTTP Headers to attach to the Request verify : SSL Verification params : Dictionary or bytes to be sent in the query string for the Request","title":"Gns3Connector.http_call()"},{"location":"api_reference/#gns3connectorget_version","text":"def get_version(self) Returns the version information of GNS3 server","title":"Gns3Connector.get_version()"},{"location":"api_reference/#gns3connectorprojects_summary","text":"def projects_summary(self, is_print=True) Returns a summary of the projects in the server. If is_print is False , it will return a list of tuples like: [(name, project_id, total_nodes, total_links, status) ...]","title":"Gns3Connector.projects_summary()"},{"location":"api_reference/#gns3connectorget_projects","text":"def get_projects(self) Returns the list of the projects on the server","title":"Gns3Connector.get_projects()"},{"location":"api_reference/#gns3connectorget_project","text":"def get_project(self, name=None, project_id=None) Retrieves a project from either a name or ID Required Attributes: name or project_id","title":"Gns3Connector.get_project()"},{"location":"api_reference/#gns3connectortemplates_summary","text":"def templates_summary(self, is_print=True) Returns a summary of the templates in the server. If is_print is False , it will return a list of tuples like: [(name, template_id, template_type, builtin, console_type, category) ...]","title":"Gns3Connector.templates_summary()"},{"location":"api_reference/#gns3connectorget_templates","text":"def get_templates(self) Returns the templates defined on the server.","title":"Gns3Connector.get_templates()"},{"location":"api_reference/#gns3connectorget_template","text":"def get_template(self, name=None, template_id=None) Retrieves a template from either a name or ID Required Attributes: name or template_id","title":"Gns3Connector.get_template()"},{"location":"api_reference/#gns3connectorget_nodes","text":"def get_nodes(self, project_id) Retieves the nodes defined on the project Required Attributes: project_id","title":"Gns3Connector.get_nodes()"},{"location":"api_reference/#gns3connectorget_node","text":"def get_node(self, project_id, node_id) Returns the node by locating its ID. Required Attributes: project_id node_id","title":"Gns3Connector.get_node()"},{"location":"api_reference/#gns3connectorget_links","text":"def get_links(self, project_id) Retrieves the links defined in the project. Required Attributes: project_id","title":"Gns3Connector.get_links()"},{"location":"api_reference/#gns3connectorget_link","text":"def get_link(self, project_id, link_id) Returns the link by locating its ID. Required Attributes: project_id link_id","title":"Gns3Connector.get_link()"},{"location":"api_reference/#gns3connectorcreate_project","text":"def create_project(self, kwargs) Pass a dictionary type object with the project parameters to be created. Required Attributes: name Returns JSON project information","title":"Gns3Connector.create_project()"},{"location":"api_reference/#gns3connectordelete_project","text":"def delete_project(self, project_id) Deletes a project from server. Required Attributes: project_id","title":"Gns3Connector.delete_project()"},{"location":"api_reference/#link-objects","text":"GNS3 Link API object. For more information visit: Links Endpoint API information Attributes: link_id (str): Link UUID ( required to be set when using get method) link_type (enum): Possible values: ethernet, serial project_id (str): Project UUID ( required ) connector (object): Gns3Connector instance used for interaction ( required ) suspend (bool): Suspend the link nodes (list): List of the Nodes and ports ( required when using create method, see Features/Link creation on the docs) filters (dict): Packet filter. This allow to simulate latency and errors capturing (bool): Read only property. True if a capture running on the link capture_file_path (str): Read only property. The full path of the capture file if capture is running capture_file_name (str): Read only property. The name of the capture file if capture is running Returns: Link instance Example: >>> link = Link(project_id=<pr_id>, link_id=<link_id> connector=<Gns3Connector instance>) >>> link.get() >>> print(link.link_type) 'ethernet'","title":"Link Objects"},{"location":"api_reference/#linkget","text":"def get(self) Retrieves the information from the link endpoint. Required Attributes: project_id connector link_id","title":"Link.get()"},{"location":"api_reference/#linkdelete","text":"def delete(self) Deletes a link endpoint from the project. It sets to None the attributes link_id when executed sucessfully Required Attributes: project_id connector link_id","title":"Link.delete()"},{"location":"api_reference/#linkcreate","text":"def create(self) Creates a link endpoint Required Attributes: project_id connector nodes","title":"Link.create()"},{"location":"api_reference/#node-objects","text":"GNS3 Node API object. For more information visit: Node Endpoint API information Attributes: name (str): Node name ( required when using create method) project_id (str): Project UUID ( required ) node_id (str): Node UUID ( required when using get method) compute_id (str): Compute identifier ( required , default=local) node_type (enum): frame_relay_switch, atm_switch, docker, dynamips, vpcs, traceng, virtualbox, vmware, iou, qemu ( required when using create method) connector (object): Gns3Connector instance used for interaction ( required ) template_id : Template UUID from the which the node is from. template : Template name from the which the node is from. node_directory (str): Working directory of the node. Read only status (enum): Possible values: stopped, started, suspended ports (list): List of node ports, READ only port_name_format (str): Formating for port name {0} will be replace by port number port_segment_size (int): Size of the port segment first_port_name (str): Name of the first port properties (dict): Properties specific to an emulator locked (bool): Whether the element locked or not label (dict): TBC console (int): Console TCP port console_host (str): Console host console_auto_start (bool): Automatically start the console when the node has started command_line (str): Command line use to start the node custom_adapters (list): TBC height (int): Height of the node, READ only width (int): Width of the node, READ only symbol (str): Symbol of the node x (int): X position of the node y (int): Y position of the node `z (int): Z position of the node Returns: Node instance Example: >>> alpine = Node(name=\"alpine1\", node_type=\"docker\", template=\"alpine\", project_id=<pr_id>, connector=<Gns3Connector instance>) >>> alpine.create() >>> print(alpine.node_id) 'SOME-UUID-GENERATED'","title":"Node Objects"},{"location":"api_reference/#nodeget","text":"def get(self, get_links=True) Retrieves the node information. When get_links is True it also retrieves the links respective to the node. Required Attributes: project_id connector node_id","title":"Node.get()"},{"location":"api_reference/#nodeget_links","text":"def get_links(self) Retrieves the links of the respective node. They will be saved at the links attribute Required Attributes: project_id connector node_id","title":"Node.get_links()"},{"location":"api_reference/#nodestart","text":"def start(self) Starts the node. Required Attributes: project_id connector node_id","title":"Node.start()"},{"location":"api_reference/#nodestop","text":"def stop(self) Stops the node. Required Attributes: project_id connector node_id","title":"Node.stop()"},{"location":"api_reference/#nodereload","text":"def reload(self) Reloads the node. Required Attributes: project_id connector node_id","title":"Node.reload()"},{"location":"api_reference/#nodesuspend","text":"def suspend(self) Suspends the node. Required Attributes: project_id connector node_id","title":"Node.suspend()"},{"location":"api_reference/#nodecreate","text":"def create(self, extra_properties={}) Creates a node. By default it will fetch the nodes properties for creation based on the template or template_id attribute supplied. This can be overriden/updated by sending a dictionary of the properties under extra_properties . Required Attributes: project_id connector compute_id : Defaults to \"local\" name node_type template or template_id","title":"Node.create()"},{"location":"api_reference/#nodedelete","text":"def delete(self) Deletes the node from the project. It sets to None the attributes node_id and name when executed successfully Required Attributes: project_id connector node_id","title":"Node.delete()"},{"location":"api_reference/#project-objects","text":"GNS3 Project API object. For more information visit: Project Endpoint API information Attributes: name : Project name ( required when using create method) project_id (str): Project UUID ( required ) connector (object): Gns3Connector instance used for interaction ( required ) status (enum): Possible values: opened, closed path (str): Path of the project on the server filename (str): Project filename auto_start (bool): Project start when opened auto_close (bool): Project auto close when client cut off the notifications feed auto_open (bool): Project open when GNS3 start drawing_grid_size (int): Grid size for the drawing area for drawings grid_size (int): Grid size for the drawing area for nodes scene_height (int): Height of the drawing area scene_width (int): Width of the drawing area show_grid (bool): Show the grid on the drawing area show_interface_labels (bool): Show interface labels on the drawing area show_layers (bool): Show layers on the drawing area snap_to_grid (bool): Snap to grid on the drawing area supplier (dict): Supplier of the project variables (list): Variables required to run the project zoom (int): Zoom of the drawing area stats (dict): Project stats nodes (list): List of Node instances present on the project links (list): List of Link instances present on the project Returns: Project instance Example: >>> lab = Project(name=\"lab\", connector=<Gns3Connector instance>) >>> lab.create() >>> print(lab.status) 'opened'","title":"Project Objects"},{"location":"api_reference/#projectget","text":"def get(self, get_links=True, get_nodes=True, get_stats=True) Retrieves the projects information. get_links : When true it also queries for the links inside the project get_nodes : When true it also queries for the nodes inside the project get_stats : When true it also queries for the stats inside the project Required Attributes: connector project_id or name","title":"Project.get()"},{"location":"api_reference/#projectcreate","text":"def create(self) Creates the project. Required Attributes: name connector","title":"Project.create()"},{"location":"api_reference/#projectupdate","text":"def update(self, kwargs) Updates the project instance by passing the keyword arguments of the attributes you want to be updated Example: lab.update(auto_close=True) This will update the project auto_close attribute to True Required Attributes: project_id connector","title":"Project.update()"},{"location":"api_reference/#projectdelete","text":"def delete(self) Deletes the project from the server. It sets to None the attributes project_id and name when executed successfully Required Attributes: project_id connector","title":"Project.delete()"},{"location":"api_reference/#projectclose","text":"def close(self) Closes the project on the server. Required Attributes: project_id connector","title":"Project.close()"},{"location":"api_reference/#projectopen","text":"def open(self) Opens the project on the server. Required Attributes: project_id connector","title":"Project.open()"},{"location":"api_reference/#projectget_stats","text":"def get_stats(self) Retrieve the stats of the project. Required Attributes: project_id connector","title":"Project.get_stats()"},{"location":"api_reference/#projectget_nodes","text":"def get_nodes(self) Retrieve the nodes of the project. Required Attributes: project_id connector","title":"Project.get_nodes()"},{"location":"api_reference/#projectget_links","text":"def get_links(self) Retrieve the links of the project. Required Attributes: project_id connector","title":"Project.get_links()"},{"location":"api_reference/#projectstart_nodes","text":"def start_nodes(self, poll_wait_time=5) Starts all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector","title":"Project.start_nodes()"},{"location":"api_reference/#projectstop_nodes","text":"def stop_nodes(self, poll_wait_time=5) Stops all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector","title":"Project.stop_nodes()"},{"location":"api_reference/#projectreload_nodes","text":"def reload_nodes(self, poll_wait_time=5) Reloads all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector","title":"Project.reload_nodes()"},{"location":"api_reference/#projectsuspend_nodes","text":"def suspend_nodes(self, poll_wait_time=5) Suspends all the nodes inside the project. poll_wait_time is used as a delay when performing the next query of the nodes status. Required Attributes: project_id connector","title":"Project.suspend_nodes()"},{"location":"api_reference/#projectnodes_summary","text":"def nodes_summary(self, is_print=True) Returns a summary of the nodes insode the project. If is_print is False , it will return a list of tuples like: [(node_name, node_status, node_console, node_id) ...] Required Attributes: project_id connector","title":"Project.nodes_summary()"},{"location":"api_reference/#projectnodes_inventory","text":"def nodes_inventory(self) Returns an inventory-style dictionary of the nodes Example: { \"router01\": { \"hostname\": \"127.0.0.1\", \"name\": \"router01\", \"console_port\": 5077, \"type\": \"vEOS\" } } Required Attributes: project_id connector","title":"Project.nodes_inventory()"},{"location":"api_reference/#projectlinks_summary","text":"def links_summary(self, is_print=True) Returns a summary of the links insode the project. If is_print is False, it will return a list of tuples like: [(node_a, port_a, node_b, port_b) ...] Required Attributes: project_id connector","title":"Project.links_summary()"},{"location":"api_reference/#projectget_node","text":"def get_node(self, name=None, node_id=None) Returns the Node object by searching for the name or the node_id . Required Attributes: project_id connector name or node_id NOTE: Run method get_nodes() manually to refresh list of nodes if necessary","title":"Project.get_node()"},{"location":"api_reference/#projectget_link","text":"def get_link(self, link_id) Returns the Link object by locating its ID Required Attributes: project_id connector link_id NOTE: Run method get_links() manually to refresh list of links if necessary","title":"Project.get_link()"},{"location":"api_reference/#projectcreate_node","text":"def create_node(self, name=None, kwargs) Creates a node. Required Attributes: project_id connector Required Keyword attributes: name node_type compute_id : Defaults to \"local\" template or template_id","title":"Project.create_node()"},{"location":"api_reference/#projectcreate_link","text":"def create_link(self, node_a, port_a, node_b, port_b) Creates a link. Required Attributes: project_id connector node_a : Node name of the A side port_a : Port name of the A side (must match the name attribute of the port) node_b : Node name of the B side port_b : Port name of the B side (must match the name attribute of the port)","title":"Project.create_link()"},{"location":"user-guide/","text":"How it works The library provide the following interfaces: Gns3Connector : Main object that interacts with the GNS3 server REST API and its objective is to be its interface. Project : Interface of a project/lab defined. Node : Interface of a node/entity defined. Link : Interface of a link defined. The Gns3Connector is mandatory and needs to be assigned to the Project , Node or Link object you want to work with, the latter uses the connector to interact with the REST API. Next you can see different ways to interact with the library. Interact with existing Project Gns3Connector and Project objects Here is an example of defining a connector object and a project that is already configured on a local GNS3 server: >>> from gns3fy import Gns3Connector, Project >>> from tabulate import tabulate >>> server = Gns3Connector(\"http://localhost:3080\") # To show the available projects on the server >>> print( tabulate( server.projects_summary(is_print=False), headers=[\"Project Name\", \"Project ID\", \"Total Nodes\", \"Total Links\", \"Status\"], ) ) \"\"\" Project Name Project ID Total Nodes Total Links Status -------------- ------------------------------------ ------------- ------------- -------- test2 c9dc56bf-37b9-453b-8f95-2845ce8908e3 10 9 opened API_TEST 4b21dfb3-675a-4efa-8613-2f7fb32e76fe 6 4 opened mpls-bgpv2 f5de5917-0ac5-4850-82b1-1d7e3c777fa1 30 40 closed \"\"\" >>> lab = Project(name=\"API_TEST\", connector=server) # Retrieve its information and display >>> lab.get() >>> print(lab) Project(project_id='4b21dfb3-675a-4efa-8613-2f7fb32e76fe', name='API_TEST', status='opened', ...) # Access the project attributes >>> print(f\"Name: {lab.name} -- Status: {lab.status} -- Is auto_closed?: {lab.auto_close}\") \"Name: API_TEST -- Status: closed -- Is auto_closed?: False\" # Open the project >>> lab.open() >>> lab.status opened # Verify the stats >>> lab.stats {'drawings': 0, 'links': 4, 'nodes': 6, 'snapshots': 0} # List the names and status of all the nodes in the project for node in lab.nodes: print(f\"Node: {node.name} -- Node Type: {node.node_type} -- Status: {node.status}\") \"\"\" Node: Ethernetswitch-1 -- Node Type: ethernet_switch -- Status: started ... \"\"\" As noted before you can also use the Gns3Connector as an interface object to the GNS3 server REST API. >>> server.get_version() {'local': False, 'version': '2.2.0b4'} >>> server.get_templates() [{'adapter_type': 'e1000', 'adapters': 13, 'bios_image': '', 'boot_priority': 'c', 'builtin': False, 'category': 'router', 'cdrom_image': '', 'compute_id': 'local', ... Node and Link objects You have access to the Node and Link objects as well, and this gives you the ability to start, stop, suspend the individual element in a GNS3 project. ... >>> PROJECT_ID = \"4b21dfb3-675a-4efa-8613-2f7fb32e76fe\" >>> alpine1 = Node(project_id=PROJECT_ID, name=\"alpine-1\", connector=server) >>> alpine1.get() >>> print(alpine1) Node(name='alpine-1', node_type='docker', node_directory= ...) # And you can access the attributes the same way as the project >>> print(f\"Name: {alpine1.name} -- Status: {alpine1.status} -- Console: {alpine1.console}\") \"Name: alpine-1 -- Status: started -- Console: 5005\" # Stop the node and start (you can just restart it as well) >>> alpine1.stop() >>> alpine1.status stopped >>> alpine1.start() >>> alpine1.status started # You can also see the Link objects assigned to this node >>> alpine1.links [Link(link_id='4d9f1235-7fd1-466b-ad26-0b4b08beb778', link_type='ethernet', ...)] # And in the same way you can interact with a Link object >>> link1 = alpine1.links[0] >>> print(f\"Link Type: {link1.link_type} -- Capturing?: {link1.capturing} -- Endpoints: {link1.nodes}\") Link Type: ethernet -- Capturing?: False -- Endpoints: [{'adapter_number': 2, ...}] Creating a new Project You can find here a couple of methods that are available on the interfaces provided by the library. To navigate to some of them and see their value, lets create a simple lab on the server with 2 nodes connected betweem each other. Project creation Lets start by creating a lab called test_lab ... >>> lab = Project(name=\"test_lab\", connector=server) >>> lab.create() >>> lab Project(project_id='e83f1275-3a6f-48f7-88ee-36386ee27a55', name='test_lab', status='opened',...) You can see you get the project_id . In GNS3 the project ID is key for all interactions under that project. Note For a complete list of the attibutes you can see the API Reference Node creation Next, lets try and create a Ethernet switch node. For this we need to know the template and node type of it. ... >>> for template in server.get_templates(): ...: if \"switch\" in template[\"name\"]: ...: print(f\"Template: {template['name']} -- ID: {template['template_id']}\") ...: \"\"\" Template: Ethernet switch -- ID: 1966b864-93e7-32d5-965f-001384eec461 Template: Frame Relay switch -- ID: dd0f6f3a-ba58-3249-81cb-a1dd88407a47 Template: ATM switch -- ID: aaa764e2-b383-300f-8a0e-3493bbfdb7d2 \"\"\" >>> server.get_template_by_name(\"Ethernet switch\") {'builtin': True, 'category': 'switch', 'console_type': 'none', 'name': 'Ethernet switch', 'symbol': ':/symbols/ethernet_switch.svg', 'template_id': '1966b864-93e7-32d5-965f-001384eec461', 'template_type': 'ethernet_switch'} By knowing the template information of the device we can create the Node instace of it ... >>> switch = Node( project_id=lab.project_id, connector=server, name=\"Ethernet-switch\", node_type=\"ethernet_switch\", template=\"Ethernet switch\" ) >>> switch.create() >>> switch Node(name='Ethernet-switch', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='c3607609-49'...) Note For a complete list of the attibutes you can see the API Reference Now lets add an docker Alpine host to the project ( NOTE: The docker image and template needs to be already configured in GNS3) ... >>> alpine = Node( project_id=lab.project_id, connector=server, name=\"alpine-host\", node_type=\"docker\", template=\"alpine\" ) >>> alpine.create() >>> alpine Node(name='alpine-host', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='8c11eb8b'...) >>> alpine.properties {'adapters': 2, 'aux': 5026, 'category': 'guest', 'console_auto_start': False, 'console_http_path': '/', 'console_http_port': 80, 'console_resolution': '1024x768', 'console_type': 'telnet', 'container_id': 'f26b6aee763a9399c93c86032b75717c57b260e5010e88c4d410ce13554771df', 'custom_adapters': [], 'environment': '', 'extra_hosts': '', 'extra_volumes': [], 'image': 'alpine:latest', 'start_command': '', 'symbol': ':/symbols/affinity/circle/gray/docker.svg', 'usage': ''} >>> alpine.ports [{'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth0', 'port_number': 0, 'short_name': 'eth0'}, {'adapter_number': 1, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth1', 'port_number': 0, 'short_name': 'eth1'}] You can access all of the host attributes and see their specifications based on the template defined on the server. To update the lab object with their latest nodes added ... >>> lab.get() # I have shorten the output shown >>> lab.nodes \"\"\" [Node(name='Ethernet-switch', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='c3607609... Node(name='alpine-host1', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='8c11eb8b... ] \"\"\" Link creation Next lets create a link between the switch and the alpine host. Switch Etherner0 <--> Alpine Eth1 ... >>> lab.create_link('Ethernet-switch', 'Ethernet0', 'alpine-host1', 'eth1') \"Created Link-ID: b0d0df11-8ed8-4d1d-98e4-3776c9b7bdce -- Type: ethernet\" >>> lab.links [Link(link_id='b0d0df11-8ed8-4d1d-98e4-3776c9b7bdce', link_type='ethernet', project_id='6e7'...)] Note For a complete list of the attibutes you can see the API Reference This is one way to create a link (using the lab object), but you can also create it using a Link instance as well. We need the link mapping to be set under the nodes attribute of the Link instance. For this we need: node_id adapter_number port_number ... >>> switch.ports [{'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'Ethernet0', 'port_number': 0, 'short_name': 'e0'}, {'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'Ethernet1', 'port_number': 1, 'short_name': 'e1'}, ... >>> alpine.ports [{'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth0', 'port_number': 0, 'short_name': 'eth0'}, {'adapter_number': 1, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth1', 'port_number': 0, 'short_name': 'eth1'}] Gettings this information from both nodes we can create the Link. ... >>> nodes = [ dict(node_id=switch.node_id, adapter_number=0, port_number=1), dict(node_id=alpine.node_id, adapter_number=0, port_number=0) ] >>> extra_link = Link(project_id=lab.project_id, connector=server, nodes=nodes) >>> extra_link.create() >>> extra_link Link(link_id='edf38e1a-67e7-4060-8493-0e222ec22072', link_type='ethernet', project_id='6e75bca5'...) You can get the latest link information on the project ... >>> lab.get_links() # You can see the 2 links created earlier >>> lab.links [Link(link_id='b0d0df11-8ed8-4d1d-98e4-3776c9b7bdce', link_type='ethernet'... Link(link_id='=', link_type='ethernet'...] You can see the final result if you open the lab on your GNS3 client: Note The devices are all clustered together. This will be addressed in the future. For te moment you can re-arrange them the way you want Examples Here are some examples of what you can do with the library Get Nodes and Links summary For a given project you can use nodes_summary and links_summary , that if used with a library like tabulate you can obtain the following: ... >>> from tabulate import tabulate >>> nodes_summary = lab.nodes_summary(is_print=False) >>> print( ... tabulate(nodes_summary, headers=[\"Node\", \"Status\", \"Console Port\", \"ID\"]) ... ) \"\"\" Node Status Console Port ID ---------------- -------- -------------- ------------------------------------ Ethernetswitch-1 started 5000 da28e1c0-9465-4f7c-b42c-49b2f4e1c64d IOU1 started 5001 de23a89a-aa1f-446a-a950-31d4bf98653c IOU2 started 5002 0d10d697-ef8d-40af-a4f3-fafe71f5458b vEOS-4.21.5F-1 started 5003 8283b923-df0e-4bc1-8199-be6fea40f500 alpine-1 started 5005 ef503c45-e998-499d-88fc-2765614b313e Cloud-1 started cde85a31-c97f-4551-9596-a3ed12c08498 \"\"\" >>> links_summary = lab.links_summary(is_print=False) >>> print( ... tabulate(links_summary, headers=[\"Node A\", \"Port A\", \"Node B\", \"Port B\"]) ... ) \"\"\" Node A Port A Node B Port B -------------- ----------- ---------------- ----------- IOU1 Ethernet1/0 IOU2 Ethernet1/0 vEOS-4.21.5F-1 Management1 Ethernetswitch-1 Ethernet0 vEOS-4.21.5F-1 Ethernet1 alpine-1 eth0 Cloud-1 eth1 Ethernetswitch-1 Ethernet7 \"\"\" I have shown the projects_summary earlier, here is another one that is helpful ... >>> print( tabulate( server.templates_summary(is_print=False), headers=[ \"Template Name\", \"Template ID\", \"Type\", \"Builtin\", \"Console\", \"Category\", ], ) ) \"\"\" Template Name Template ID Type Builtin Console Category ------------------ ------------------------------------ ------------------ --------- --------- ---------- IOU-L3 8504c605-7914-4a8f-9cd4-a2638382db0e iou False telnet router IOU-L2 92cccfb2-6401-48f2-8964-3c75323be3cb iou False telnet switch vEOS c6203d4b-d0ce-4951-bf18-c44369d46804 qemu False telnet router alpine 847e5333-6ac9-411f-a400-89838584371b docker False telnet guest Cloud 39e257dc-8412-3174-b6b3-0ee3ed6a43e9 cloud True N/A guest NAT df8f4ea9-33b7-3e96-86a2-c39bc9bb649c nat True N/A guest VPCS 19021f99-e36f-394d-b4a1-8aaa902ab9cc vpcs True N/A guest Ethernet switch 1966b864-93e7-32d5-965f-001384eec461 ethernet_switch True none switch Ethernet hub b4503ea9-d6b6-3695-9fe4-1db3b39290b0 ethernet_hub True N/A switch Frame Relay switch dd0f6f3a-ba58-3249-81cb-a1dd88407a47 frame_relay_switch True N/A switch ATM switch aaa764e2-b383-300f-8a0e-3493bbfdb7d2 atm_switch True N/A switch \"\"\" Manipulate a Node from a Project The Project object gives you all the nodes configured on it. This is typically saved under Project.nodes as a list of Node instances. When collecting the information of a project on a given time, you also retrieve by default all of its nodes. Each of the nodes are assigned the Gns3Connector by default if you follow the procedure below. ... >>> server = Gns3Connector(url=\"http://localhost:3080\")] >>> print(server) '<gns3fy.gns3fy.Gns3Connector at 0x10d4c8e10>' >>> lab = Project(name=\"lab\", connector=server) # Retrieve the lab information and print the amount of nodes configured >>> lab.get() >>> print(len(lab.nodes)) 2 # Assign one of the nodes to a varaible and start manipulating it >>> node_1 = lab.nodes[0] >>> print(node_1.status) 'stopped' >>> node_1.start() >>> print(node_1.status) 'started' >>> print(node_1.connector) '<gns3fy.gns3fy.Gns3Connector at 0x10d4c8e10>' node_1 has the same connector object as reference for interaction with the server. The same can be done with a Link by interacting with the Project.links attribute.","title":"User Guide"},{"location":"user-guide/#interact-with-existing-project","text":"","title":"Interact with existing Project"},{"location":"user-guide/#gns3connector-and-project-objects","text":"Here is an example of defining a connector object and a project that is already configured on a local GNS3 server: >>> from gns3fy import Gns3Connector, Project >>> from tabulate import tabulate >>> server = Gns3Connector(\"http://localhost:3080\") # To show the available projects on the server >>> print( tabulate( server.projects_summary(is_print=False), headers=[\"Project Name\", \"Project ID\", \"Total Nodes\", \"Total Links\", \"Status\"], ) ) \"\"\" Project Name Project ID Total Nodes Total Links Status -------------- ------------------------------------ ------------- ------------- -------- test2 c9dc56bf-37b9-453b-8f95-2845ce8908e3 10 9 opened API_TEST 4b21dfb3-675a-4efa-8613-2f7fb32e76fe 6 4 opened mpls-bgpv2 f5de5917-0ac5-4850-82b1-1d7e3c777fa1 30 40 closed \"\"\" >>> lab = Project(name=\"API_TEST\", connector=server) # Retrieve its information and display >>> lab.get() >>> print(lab) Project(project_id='4b21dfb3-675a-4efa-8613-2f7fb32e76fe', name='API_TEST', status='opened', ...) # Access the project attributes >>> print(f\"Name: {lab.name} -- Status: {lab.status} -- Is auto_closed?: {lab.auto_close}\") \"Name: API_TEST -- Status: closed -- Is auto_closed?: False\" # Open the project >>> lab.open() >>> lab.status opened # Verify the stats >>> lab.stats {'drawings': 0, 'links': 4, 'nodes': 6, 'snapshots': 0} # List the names and status of all the nodes in the project for node in lab.nodes: print(f\"Node: {node.name} -- Node Type: {node.node_type} -- Status: {node.status}\") \"\"\" Node: Ethernetswitch-1 -- Node Type: ethernet_switch -- Status: started ... \"\"\" As noted before you can also use the Gns3Connector as an interface object to the GNS3 server REST API. >>> server.get_version() {'local': False, 'version': '2.2.0b4'} >>> server.get_templates() [{'adapter_type': 'e1000', 'adapters': 13, 'bios_image': '', 'boot_priority': 'c', 'builtin': False, 'category': 'router', 'cdrom_image': '', 'compute_id': 'local', ...","title":"Gns3Connector and Project objects"},{"location":"user-guide/#node-and-link-objects","text":"You have access to the Node and Link objects as well, and this gives you the ability to start, stop, suspend the individual element in a GNS3 project. ... >>> PROJECT_ID = \"4b21dfb3-675a-4efa-8613-2f7fb32e76fe\" >>> alpine1 = Node(project_id=PROJECT_ID, name=\"alpine-1\", connector=server) >>> alpine1.get() >>> print(alpine1) Node(name='alpine-1', node_type='docker', node_directory= ...) # And you can access the attributes the same way as the project >>> print(f\"Name: {alpine1.name} -- Status: {alpine1.status} -- Console: {alpine1.console}\") \"Name: alpine-1 -- Status: started -- Console: 5005\" # Stop the node and start (you can just restart it as well) >>> alpine1.stop() >>> alpine1.status stopped >>> alpine1.start() >>> alpine1.status started # You can also see the Link objects assigned to this node >>> alpine1.links [Link(link_id='4d9f1235-7fd1-466b-ad26-0b4b08beb778', link_type='ethernet', ...)] # And in the same way you can interact with a Link object >>> link1 = alpine1.links[0] >>> print(f\"Link Type: {link1.link_type} -- Capturing?: {link1.capturing} -- Endpoints: {link1.nodes}\") Link Type: ethernet -- Capturing?: False -- Endpoints: [{'adapter_number': 2, ...}]","title":"Node and Link objects"},{"location":"user-guide/#creating-a-new-project","text":"You can find here a couple of methods that are available on the interfaces provided by the library. To navigate to some of them and see their value, lets create a simple lab on the server with 2 nodes connected betweem each other.","title":"Creating a new Project"},{"location":"user-guide/#project-creation","text":"Lets start by creating a lab called test_lab ... >>> lab = Project(name=\"test_lab\", connector=server) >>> lab.create() >>> lab Project(project_id='e83f1275-3a6f-48f7-88ee-36386ee27a55', name='test_lab', status='opened',...) You can see you get the project_id . In GNS3 the project ID is key for all interactions under that project. Note For a complete list of the attibutes you can see the API Reference","title":"Project creation"},{"location":"user-guide/#node-creation","text":"Next, lets try and create a Ethernet switch node. For this we need to know the template and node type of it. ... >>> for template in server.get_templates(): ...: if \"switch\" in template[\"name\"]: ...: print(f\"Template: {template['name']} -- ID: {template['template_id']}\") ...: \"\"\" Template: Ethernet switch -- ID: 1966b864-93e7-32d5-965f-001384eec461 Template: Frame Relay switch -- ID: dd0f6f3a-ba58-3249-81cb-a1dd88407a47 Template: ATM switch -- ID: aaa764e2-b383-300f-8a0e-3493bbfdb7d2 \"\"\" >>> server.get_template_by_name(\"Ethernet switch\") {'builtin': True, 'category': 'switch', 'console_type': 'none', 'name': 'Ethernet switch', 'symbol': ':/symbols/ethernet_switch.svg', 'template_id': '1966b864-93e7-32d5-965f-001384eec461', 'template_type': 'ethernet_switch'} By knowing the template information of the device we can create the Node instace of it ... >>> switch = Node( project_id=lab.project_id, connector=server, name=\"Ethernet-switch\", node_type=\"ethernet_switch\", template=\"Ethernet switch\" ) >>> switch.create() >>> switch Node(name='Ethernet-switch', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='c3607609-49'...) Note For a complete list of the attibutes you can see the API Reference Now lets add an docker Alpine host to the project ( NOTE: The docker image and template needs to be already configured in GNS3) ... >>> alpine = Node( project_id=lab.project_id, connector=server, name=\"alpine-host\", node_type=\"docker\", template=\"alpine\" ) >>> alpine.create() >>> alpine Node(name='alpine-host', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='8c11eb8b'...) >>> alpine.properties {'adapters': 2, 'aux': 5026, 'category': 'guest', 'console_auto_start': False, 'console_http_path': '/', 'console_http_port': 80, 'console_resolution': '1024x768', 'console_type': 'telnet', 'container_id': 'f26b6aee763a9399c93c86032b75717c57b260e5010e88c4d410ce13554771df', 'custom_adapters': [], 'environment': '', 'extra_hosts': '', 'extra_volumes': [], 'image': 'alpine:latest', 'start_command': '', 'symbol': ':/symbols/affinity/circle/gray/docker.svg', 'usage': ''} >>> alpine.ports [{'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth0', 'port_number': 0, 'short_name': 'eth0'}, {'adapter_number': 1, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth1', 'port_number': 0, 'short_name': 'eth1'}] You can access all of the host attributes and see their specifications based on the template defined on the server. To update the lab object with their latest nodes added ... >>> lab.get() # I have shorten the output shown >>> lab.nodes \"\"\" [Node(name='Ethernet-switch', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='c3607609... Node(name='alpine-host1', project_id='6e75bca5-3fa0-4219-a7cf-f82c0540fb73', node_id='8c11eb8b... ] \"\"\"","title":"Node creation"},{"location":"user-guide/#link-creation","text":"Next lets create a link between the switch and the alpine host. Switch Etherner0 <--> Alpine Eth1 ... >>> lab.create_link('Ethernet-switch', 'Ethernet0', 'alpine-host1', 'eth1') \"Created Link-ID: b0d0df11-8ed8-4d1d-98e4-3776c9b7bdce -- Type: ethernet\" >>> lab.links [Link(link_id='b0d0df11-8ed8-4d1d-98e4-3776c9b7bdce', link_type='ethernet', project_id='6e7'...)] Note For a complete list of the attibutes you can see the API Reference This is one way to create a link (using the lab object), but you can also create it using a Link instance as well. We need the link mapping to be set under the nodes attribute of the Link instance. For this we need: node_id adapter_number port_number ... >>> switch.ports [{'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'Ethernet0', 'port_number': 0, 'short_name': 'e0'}, {'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'Ethernet1', 'port_number': 1, 'short_name': 'e1'}, ... >>> alpine.ports [{'adapter_number': 0, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth0', 'port_number': 0, 'short_name': 'eth0'}, {'adapter_number': 1, 'data_link_types': {'Ethernet': 'DLT_EN10MB'}, 'link_type': 'ethernet', 'name': 'eth1', 'port_number': 0, 'short_name': 'eth1'}] Gettings this information from both nodes we can create the Link. ... >>> nodes = [ dict(node_id=switch.node_id, adapter_number=0, port_number=1), dict(node_id=alpine.node_id, adapter_number=0, port_number=0) ] >>> extra_link = Link(project_id=lab.project_id, connector=server, nodes=nodes) >>> extra_link.create() >>> extra_link Link(link_id='edf38e1a-67e7-4060-8493-0e222ec22072', link_type='ethernet', project_id='6e75bca5'...) You can get the latest link information on the project ... >>> lab.get_links() # You can see the 2 links created earlier >>> lab.links [Link(link_id='b0d0df11-8ed8-4d1d-98e4-3776c9b7bdce', link_type='ethernet'... Link(link_id='=', link_type='ethernet'...] You can see the final result if you open the lab on your GNS3 client: Note The devices are all clustered together. This will be addressed in the future. For te moment you can re-arrange them the way you want","title":"Link creation"},{"location":"user-guide/#examples","text":"Here are some examples of what you can do with the library","title":"Examples"},{"location":"user-guide/#get-nodes-and-links-summary","text":"For a given project you can use nodes_summary and links_summary , that if used with a library like tabulate you can obtain the following: ... >>> from tabulate import tabulate >>> nodes_summary = lab.nodes_summary(is_print=False) >>> print( ... tabulate(nodes_summary, headers=[\"Node\", \"Status\", \"Console Port\", \"ID\"]) ... ) \"\"\" Node Status Console Port ID ---------------- -------- -------------- ------------------------------------ Ethernetswitch-1 started 5000 da28e1c0-9465-4f7c-b42c-49b2f4e1c64d IOU1 started 5001 de23a89a-aa1f-446a-a950-31d4bf98653c IOU2 started 5002 0d10d697-ef8d-40af-a4f3-fafe71f5458b vEOS-4.21.5F-1 started 5003 8283b923-df0e-4bc1-8199-be6fea40f500 alpine-1 started 5005 ef503c45-e998-499d-88fc-2765614b313e Cloud-1 started cde85a31-c97f-4551-9596-a3ed12c08498 \"\"\" >>> links_summary = lab.links_summary(is_print=False) >>> print( ... tabulate(links_summary, headers=[\"Node A\", \"Port A\", \"Node B\", \"Port B\"]) ... ) \"\"\" Node A Port A Node B Port B -------------- ----------- ---------------- ----------- IOU1 Ethernet1/0 IOU2 Ethernet1/0 vEOS-4.21.5F-1 Management1 Ethernetswitch-1 Ethernet0 vEOS-4.21.5F-1 Ethernet1 alpine-1 eth0 Cloud-1 eth1 Ethernetswitch-1 Ethernet7 \"\"\" I have shown the projects_summary earlier, here is another one that is helpful ... >>> print( tabulate( server.templates_summary(is_print=False), headers=[ \"Template Name\", \"Template ID\", \"Type\", \"Builtin\", \"Console\", \"Category\", ], ) ) \"\"\" Template Name Template ID Type Builtin Console Category ------------------ ------------------------------------ ------------------ --------- --------- ---------- IOU-L3 8504c605-7914-4a8f-9cd4-a2638382db0e iou False telnet router IOU-L2 92cccfb2-6401-48f2-8964-3c75323be3cb iou False telnet switch vEOS c6203d4b-d0ce-4951-bf18-c44369d46804 qemu False telnet router alpine 847e5333-6ac9-411f-a400-89838584371b docker False telnet guest Cloud 39e257dc-8412-3174-b6b3-0ee3ed6a43e9 cloud True N/A guest NAT df8f4ea9-33b7-3e96-86a2-c39bc9bb649c nat True N/A guest VPCS 19021f99-e36f-394d-b4a1-8aaa902ab9cc vpcs True N/A guest Ethernet switch 1966b864-93e7-32d5-965f-001384eec461 ethernet_switch True none switch Ethernet hub b4503ea9-d6b6-3695-9fe4-1db3b39290b0 ethernet_hub True N/A switch Frame Relay switch dd0f6f3a-ba58-3249-81cb-a1dd88407a47 frame_relay_switch True N/A switch ATM switch aaa764e2-b383-300f-8a0e-3493bbfdb7d2 atm_switch True N/A switch \"\"\"","title":"Get Nodes and Links summary"},{"location":"user-guide/#manipulate-a-node-from-a-project","text":"The Project object gives you all the nodes configured on it. This is typically saved under Project.nodes as a list of Node instances. When collecting the information of a project on a given time, you also retrieve by default all of its nodes. Each of the nodes are assigned the Gns3Connector by default if you follow the procedure below. ... >>> server = Gns3Connector(url=\"http://localhost:3080\")] >>> print(server) '<gns3fy.gns3fy.Gns3Connector at 0x10d4c8e10>' >>> lab = Project(name=\"lab\", connector=server) # Retrieve the lab information and print the amount of nodes configured >>> lab.get() >>> print(len(lab.nodes)) 2 # Assign one of the nodes to a varaible and start manipulating it >>> node_1 = lab.nodes[0] >>> print(node_1.status) 'stopped' >>> node_1.start() >>> print(node_1.status) 'started' >>> print(node_1.connector) '<gns3fy.gns3fy.Gns3Connector at 0x10d4c8e10>' node_1 has the same connector object as reference for interaction with the server. The same can be done with a Link by interacting with the Project.links attribute.","title":"Manipulate a Node from a Project"},{"location":"about/changelog/","text":"Releases 0.3.0 Added: tox for pipeline testing. projects_summary and templates_summary methods for Gns3Connector . 0.2.0 New features: Ability to create Project , Node and Link instances Created most of the methods to interact with the REST API Endpoints. Added some commodity methods like nodes_summary Created the docs Improved the tests and coverage Added CircleCI with the following checks: flake8 black formatting pytest 0.1.1 Enhancement - Adding Gns3Connector method get_version 0.1.0 Initial Push","title":"Release Notes"},{"location":"about/changelog/#030","text":"Added: tox for pipeline testing. projects_summary and templates_summary methods for Gns3Connector .","title":"0.3.0"},{"location":"about/changelog/#020","text":"New features: Ability to create Project , Node and Link instances Created most of the methods to interact with the REST API Endpoints. Added some commodity methods like nodes_summary Created the docs Improved the tests and coverage Added CircleCI with the following checks: flake8 black formatting pytest","title":"0.2.0"},{"location":"about/changelog/#011","text":"Enhancement - Adding Gns3Connector method get_version","title":"0.1.1"},{"location":"about/changelog/#010","text":"Initial Push","title":"0.1.0"},{"location":"about/license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"{}\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright 2019 David Flores Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"}]}